{"version":3,"sources":["components/loader/index.js","store/constants/index.js","app/app.module.css","store/index.js","store/reducers/api.js","store/reducers/entities.js","store/reducers/meta.js","store/reducers/collection.js","store/middleware/cache.js","store/middleware/api.js","app/index.js","store/reducers/index.js","serviceWorker.js","index.js"],"names":["__webpack_require__","d","__webpack_exports__","Loader","withLoader","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_ref","_ref$msg","msg","a","createElement","Component","opts","arguments","length","undefined","props","fallback","CALL_API","CALL_API_REQUEST","CALL_API_SUCCESS","CALL_API_FAILURE","module","exports","container","apiHost","reducerFactory","filter","initialState","reducer","state","action","createSuccessReducer","compose","not","has","createMetaReducer","anyPass","extract","path","reducers_entities","entities","Object","keys","mergeDeepRight","extractMeta","either","extractKey","meta","key","defineProperty","reducers_collection","collection","Array","isArray","merge","fetchingCache","url","pathOr","infiniteCache","params","or","isCallAPIRequest","payload","errorPayload","omit","prop","middleware_api","dispatch","getState","next","_path","query","_path$method","method","cache","types","data","transform","options","call","objectWithoutProperties","checkCache","Promise","resolve","actionMeta","type","request","fetching","fetched","error","axios","concat","then","response","success","catch","failure","reject","Posts","lazy","all","e","bind","Post","store","createStore","additionalReducers","reducers","objectSpread","collections","combineReducers","applyMiddleware","createLogger","predicate","process","createAPIMiddleWare","Boolean","window","location","hostname","match","ReactDOM","render","react_default","console","log","className","classNames","es","BrowserRouter","basename","Switch","Route","exact","component","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f665c226.chunk.js","sourcesContent":["import React, { Suspense } from 'react';\n\nexport default function Loader({ msg = 'Loading...' }) {\n  return <p>{msg}</p>;\n}\n\nexport const withLoader = (Component, opts = {}) => props => (\n  <Suspense fallback={<Loader msg={opts.msg} />}>\n    <Component {...props} />\n  </Suspense>\n);\n","export const CALL_API = 'CALL_API';\nexport const CALL_API_REQUEST = 'CALL_API_REQUEST';\nexport const CALL_API_SUCCESS = 'CALL_API_SUCCESS';\nexport const CALL_API_FAILURE = 'CALL_API_FAILURE';\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"app_container__2ujwH\"};","import { createStore, applyMiddleware } from 'redux';\nimport { createLogger } from 'redux-logger';\n\nimport reducers from './reducers';\nimport createAPIMiddleWare from './middleware/api';\n\nexport default apiHost =>\n  createStore(\n    reducers(),\n    applyMiddleware(\n      createLogger({\n        predicate: () => process.env.NODE_ENV !== 'test',\n      }),\n      createAPIMiddleWare(apiHost)\n    )\n  );\n","import { not, compose, has, anyPass } from 'ramda';\n\nimport {\n  CALL_API_FAILURE,\n  CALL_API_SUCCESS,\n  CALL_API_REQUEST,\n} from '../constants';\n\nconst reducerFactory = (filter, initialState = {}) => reducer => (\n  state,\n  action\n) => {\n  if (filter(action)) {\n    return state || initialState;\n  }\n\n  return reducer(state, action);\n};\n\nexport default reducerFactory;\n\nexport const createSuccessReducer = reducerFactory(\n  compose(\n    not,\n    has(CALL_API_SUCCESS)\n  )\n);\n\nexport const createMetaReducer = reducerFactory(\n  compose(\n    not,\n    anyPass([\n      has(CALL_API_FAILURE),\n      has(CALL_API_SUCCESS),\n      has(CALL_API_REQUEST),\n    ])\n  )\n);\n","import { mergeDeepRight, path } from 'ramda';\n\nimport { CALL_API_SUCCESS } from '../constants';\n\nconst extract = path([CALL_API_SUCCESS, 'payload', 'entities']);\n\nexport default (state, action) => {\n  const entities = extract(action);\n\n  if (!entities || !Object.keys(entities).length) {\n    return state;\n  }\n\n  return mergeDeepRight(state, extract(action));\n};\n","import { mergeDeepRight, path, either, compose } from 'ramda';\n\nimport {\n  CALL_API_SUCCESS,\n  CALL_API_FAILURE,\n  CALL_API_REQUEST,\n} from '../constants';\n\nconst extractMeta = compose(\n  path(['meta']),\n  either(\n    either(path([CALL_API_SUCCESS]), path([CALL_API_FAILURE])),\n    path([CALL_API_REQUEST])\n  )\n);\n\nconst extractKey = path(['meta', 'url']);\n\nexport default (state, action) => {\n  const key = extractKey(action);\n\n  return mergeDeepRight(state, {\n    [key]: extractMeta(action),\n  });\n};\n","import { merge, path } from 'ramda';\n\nimport { CALL_API_SUCCESS } from '../constants';\n\nconst extract = path([CALL_API_SUCCESS, 'payload', 'result']);\nconst extractKey = path(['meta', 'url']);\n\nexport default (state, action) => {\n  const collection = extract(action);\n\n  if (!collection || !Array.isArray(collection)) {\n    return state;\n  }\n\n  const key = extractKey(action);\n\n  return merge(state, {\n    [key]: collection,\n  });\n};\n","import { pathOr, or } from 'ramda';\n\nexport const fetchingCache = (state, url) => {\n  return pathOr(false, ['meta', url, 'fetching'], state);\n};\n\nexport const infiniteCache = (state, url, params) => {\n  return (\n    !pathOr(false, ['force'], params) &&\n    or(\n      pathOr(false, ['meta', url, 'fetched'], state),\n      pathOr(false, ['meta', url, 'fetching'], state)\n    )\n  );\n};\n\nexport default cache => {\n  if (typeof cache === 'function') {\n    return cache;\n  }\n\n  return cache ? infiniteCache : fetchingCache;\n};\n","import { has, pathOr, path, omit, prop, compose } from 'ramda';\nimport axios from 'axios';\n\nimport {\n  CALL_API,\n  CALL_API_SUCCESS,\n  CALL_API_FAILURE,\n  CALL_API_REQUEST,\n} from '../constants';\n\nimport checkCache from './cache';\n\nconst isCallAPIRequest = has(CALL_API);\n\nconst payload = pathOr([], ['data']);\nconst errorPayload = compose(\n  omit(['config', 'request']),\n  prop('response')\n);\n\nexport default apiHost => ({ dispatch, getState }) => {\n  return next => {\n    return action => {\n      if (!isCallAPIRequest(action)) {\n        return next(action);\n      }\n\n      const {\n        url,\n        query,\n        method = 'get',\n        cache,\n        types,\n        data,\n        transform,\n        call,\n        ...options\n      } = path([CALL_API], action);\n\n      if (method === 'get' && checkCache(cache)(getState(), url, query)) {\n        return Promise.resolve();\n      }\n\n      const actionMeta = {\n        url,\n        method,\n        query,\n        options,\n      };\n\n      dispatch({\n        type: types.request,\n        meta: actionMeta,\n        [CALL_API_REQUEST]: {\n          meta: {\n            fetching: true,\n            fetched: null,\n            error: null,\n          },\n        },\n      });\n\n      return axios({\n        method,\n        url: `${apiHost}${url}`,\n        data,\n      })\n        .then(response => {\n          dispatch({\n            type: types.success,\n            meta: actionMeta,\n            [CALL_API_SUCCESS]: {\n              payload: !!transform\n                ? transform(payload(response))\n                : payload(response),\n              meta: {\n                fetching: false,\n                fetched: true,\n                error: null,\n              },\n            },\n          });\n\n          return payload(response);\n        })\n        .catch(error => {\n          const response = errorPayload(error);\n          dispatch({\n            type: types.failure,\n            meta: actionMeta,\n            [CALL_API_FAILURE]: {\n              meta: {\n                fetching: false,\n                fetched: true,\n                error: response,\n              },\n            },\n          });\n\n          return Promise.reject(response);\n        });\n    };\n  };\n};\n","import React, { lazy } from 'react';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nimport createStore from '../store/index.js';\nimport classNames from './app.module.css';\nimport { withLoader } from '../components/loader';\n\nconst Posts = lazy(() => import('../pages/posts'));\nconst Post = lazy(() => import('../pages/post'));\n\n// API Host can be changed (in abstract future) via ENV\nconst store = createStore('https://jsonplaceholder.typicode.com');\n\nexport default function App() {\n  console.log(process.env.PUBLIC_URL);\n\n  return (\n    <div className={classNames.container}>\n      <Provider store={store}>\n        <Router basename={process.env.PUBLIC_URL}>\n          <Switch>\n            <Route\n              path={process.env.PUBLIC_URL}\n              exact\n              component={withLoader(Posts)}\n            />\n            <Route\n              path={`${process.env.PUBLIC_URL}/post/:id`}\n              exact\n              component={withLoader(Post)}\n            />\n            <Route\n              component={() => (\n                <div className=\"page\">\n                  <h1>Not found</h1>\n                </div>\n              )}\n            />\n          </Switch>\n        </Router>\n      </Provider>\n    </div>\n  );\n}\n","import { combineReducers } from 'redux';\nimport { createSuccessReducer, createMetaReducer } from './api';\n\nimport entities from './entities';\nimport meta from './meta';\nimport collection from './collection';\n\nexport default (additionalReducers = {}) => {\n  const reducers = {\n    meta: createMetaReducer(meta),\n    entities: createSuccessReducer(entities),\n    collections: createSuccessReducer(collection),\n    ...additionalReducers,\n  };\n\n  return combineReducers(reducers);\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './styles/index.css';\n\nimport App from './app';\n\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}